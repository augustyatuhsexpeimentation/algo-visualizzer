export const SORT_PSEUDOCODE: Record<string, string[]> = {
  bubble: [
    "procedure bubbleSort(A: list)",
    "  n = length(A)",
    "  for i = 0 to n-1 do",
    "    for j = 0 to n-i-2 do",
    "      if A[j] > A[j+1] then",
    "        swap(A[j], A[j+1])",
    "      end if",
    "    end for",
    "  end for",
    "end procedure",
  ],
  merge: [
    "procedure mergeSort(A, left, right)",
    "  if left < right then",
    "    mid = (left + right) / 2",
    "    mergeSort(A, left, mid)",
    "    mergeSort(A, mid+1, right)",
    "    merge(A, left, mid, right)",
    "  end if",
    "end procedure",
    "",
    "procedure merge(A, left, mid, right)",
    "  create L = A[left..mid]",
    "  create R = A[mid+1..right]",
    "  i = 0, j = 0, k = left",
    "  while i < |L| and j < |R| do",
    "    if L[i] <= R[j] then",
    "      A[k] = L[i]; i++",
    "    else",
    "      A[k] = R[j]; j++",
    "    end if",
    "    k++",
    "  end while",
    "  copy remaining L to A",
    "  copy remaining R to A",
    "end procedure",
  ],
  quick: [
    "procedure quickSort(A, low, high)",
    "  if low < high then",
    "    p = partition(A, low, high)",
    "    quickSort(A, low, p-1)",
    "    quickSort(A, p+1, high)",
    "  end if",
    "end procedure",
    "",
    "procedure partition(A, low, high)",
    "  pivot = A[high]",
    "  i = low - 1",
    "  for j = low to high-1 do",
    "    if A[j] < pivot then",
    "      i++",
    "      swap(A[i], A[j])",
    "    end if",
    "  end for",
    "  swap(A[i+1], A[high])",
    "  return i + 1",
    "end procedure",
  ],
};

export const GRAPH_PSEUDOCODE: Record<string, string[]> = {
  bfs: [
    "procedure BFS(G, start)",
    "  create queue Q",
    "  mark start as visited",
    "  enqueue start into Q",
    "  while Q is not empty do",
    "    v = dequeue from Q",
    "    for each neighbor u of v do",
    "      if u is not visited then",
    "        mark u as visited",
    "        enqueue u into Q",
    "      end if",
    "    end for",
    "  end while",
    "end procedure",
  ],
  dfs: [
    "procedure DFS(G, start)",
    "  create stack S",
    "  push start onto S",
    "  while S is not empty do",
    "    v = pop from S",
    "    if v is not visited then",
    "      mark v as visited",
    "      for each neighbor u of v do",
    "        if u is not visited then",
    "          push u onto S",
    "        end if",
    "      end for",
    "    end if",
    "  end while",
    "end procedure",
  ],
  dijkstra: [
    "procedure Dijkstra(G, start)",
    "  for each vertex v in G do",
    "    dist[v] = INFINITY",
    "    prev[v] = NULL",
    "  end for",
    "  dist[start] = 0",
    "  create priority queue Q",
    "  add all vertices to Q",
    "  while Q is not empty do",
    "    u = vertex with min dist in Q",
    "    remove u from Q",
    "    for each neighbor v of u do",
    "      alt = dist[u] + weight(u, v)",
    "      if alt < dist[v] then",
    "        dist[v] = alt",
    "        prev[v] = u",
    "      end if",
    "    end for",
    "  end while",
    "end procedure",
  ],
};